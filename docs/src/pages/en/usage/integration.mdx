---
title: Integration
description: Integration
layout: ../../../layouts/docs.astro
lang: en
---

import CodeCopy from "../../../components/code-copy.astro";

# Integration

Getting started with Kernel includes configuring assets and environments and linking/generating plugins. Afterward, you will no longer have to worry about maintaining those native code directories (i.e., iOS and Android). You will be able to extend your setup and get idempotent native code generation. 

## Add Core and CLI Packages

<div class="flex w-full my-6">
  <CodeCopy args="yarn add -D @brandingbrand/kernel-core @brandingbrand/kernel-cli" />
</div>

### Configuring Assets

At the root of your project:
- Add `ios` and `android` directories to your project's `.gitignore` file.
- Remove the iOS and Android directories
  - `rm -rf ios android` 
- Create `.kernelrcdirectory`
  - This is the Kernel runtime configuration directory where all configurations will be hosted, i.e., CaC. 
- Inside `.kernelrc`` create an env directory 

#### Directories
Additional directories are recommended for the separation of concerns. Inside `.kernelrc`, create a `signing` directory - this will be where your native codesigning exists. For iOS, this would be certs and profiles, and for Android, it will be your keystores. 

For example, it is beneficial to break down your iOS codesigning assets into their respective environments (e.g., enterprise, adhoc, store, etc.). This way, only a minimal set of profiles and certs are configured when you add codesigning keys for CI/CD. 


##### .kernelrc
Inside `.kernelrc` create an `assets` directory - this will be useful to host all plugin assets. To follow along, check out this [**example**](https://github.com/brandingbrand/flagship/tree/feat/flagship-12/apps/react-native/.kernelrc).


After completing the prior steps, your `.kernelrc` directory should now resemble the following:

```
.kernelrc
├── assets
├── env
└── signing
```

##### .assets
Will generally include files related to plugins i.e. *.png for app icons, *.png for splash screen, google-services.json for firebase, etc. To follow along, check out this [**example**](https://github.com/brandingbrand/flagship/tree/feat/flagship-12/apps/react-native/.kernelrc/assets).

```
./assets
├── app-icon
│   ├── android-adaptive-background.png
│   ├── android-adaptive-foreground.png
│   ├── android-legacy.png
│   └── ios-universal.png
├── extensions
│   └── notifications
│       ├── notifications-Info.plist
│       ├── notifications.h
│       └── notifications.m
├── fonts
│   ├── Font-Bold.ttf
│   ├── Font-ExtraBold.ttf
│   ├── Font-ExtraLight.ttf
│   ├── Font-Light.ttf
│   ├── Font-Medium.ttf
│   ├── Font-Regular.ttf
│   └── Font-SemiBold.ttf
└── splash-screen
    ├── android
    │   └── generated
    │       └── logo.png
    └── ios
        └── generated
            └── logo.png
```

##### .env
Will be your collective your environment files i.e. development, production, adhoc, etc. These are TypeScript files based on the `@brandingbrand/kernel-core` exported type `Config<T>`. To follow along, check out this [**example**](https://github.com/brandingbrand/flagship/tree/feat/flagship-12/apps/react-native/.kernelrc/env).

```
./env
├── env.dev.ts
└── env.prod.ts
```
##### .signing
Will host all of your files related to codesigning. Android codesigning relates to your *.keystore. iOS codesigning relates to your certificates, entitlements and provisioning profiles. To follow along, check out this [**example**](https://github.com/brandingbrand/flagship/tree/feat/flagship-12/apps/react-native/.kernelrc/signing).

```
./signing
├── AppleWWDRCA.cer
├── release.keystore
├── enterprise
│   ├── enterprise.cer
│   ├── enterprise.entitlements
│   ├── enterprise.mobileprovision
│   ├── enterprise.p12
│   └── enterprise_notification.mobileprovision
└── store
    ├── store.cer
    ├── store.entitlements
    ├── store.mobileprovision
    ├── store.p12
    └── store_notification.mobileprovision
```

### Configuring Environments

#### Basic

Environments are the foundation of Kernel - this is the Configuration as Code (CaC) content. 

In the `.kernelrc/env` directory create an environment file (e.g., env.prod.ts). Import the `Config` from `@brandingbrand/kernel-core`. This will allow you to generate a basic build configuration for iOS and Android. 

Plugin types can be imported and extended upon the base config i.e. `Config & KernelPluginAsset`. With this simplistic approach you get a build configuration with plugins.

```
import {Config} from '@brandingbrand/kernel-core';
import {KernelPluginAsset} from '@brandingbrand/kernel-plugin-asset';

const prod: Config & KernelPluginAsset = {
  ios: {
    name: 'kernel',
    bundleId: 'com.kernel',
    displayName: 'Kernel',
    .
    .
    .
  },
  android: {
    name: 'kernel',
    displayName: 'Kernel',
    packageName: 'com.kernel',
    .
    .
    .
  },
  app: {},
  kernelPluginAsset: {
    kernel: {
      assetPath: ['assets/fonts'],
    },
  },
};

export default prod;
```

#### Advanced

The advanced approach will allow you take advantage of build + runtime configurations from a single env. 

We will utilize TypeScript's [**triple-dash directive**](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html) to solve for a single source of truth. 

- Move the environment type to a common location inside the `src/types` directory. 
- Inside the `src/types` directory create an `app.d.ts` files - a type declaration file. 
- In this file we will define our overall app type. 
  - If you are utilizing `fsapp` we will overwrite the `any` `env` type with our defined type via `fsapp.d.ts` file - this will provide us with type-hints when utilizing runtime configurations. 
- To follow along, check out this [**example**](https://github.com/brandingbrand/flagship/blob/feat/flagship-12/apps/react-native/src/types).

In `app.d.ts` you will define the build + runtime configuration, where the interface `App` is your runtime configuration:

`app.d.ts`
```
declare module '@brandingbrand/kernel-app' {
  type ENV = import('@brandingbrand/kernel-core').Config<App> &
    import('@brandingbrand/kernel-plugin-asset').KernelPluginAsset &
    import('@brandingbrand/kernel-plugin-app-icon').KernelPluginAppIcon &
    import('@brandingbrand/kernel-plugin-fastlane').KernelPluginFastlane &
    import('@brandingbrand/kernel-plugin-permissions').KernelPluginPermissions &
    import('@brandingbrand/kernel-plugin-splash-screen').KernelPluginSplashScreen &
    import('@brandingbrand/kernel-plugin-target-extension').KernelPluginTargetExtension;

  interface App {
    foo: string;
    bar: number;
  }
}
```

`fsapp.d.ts`
```
import '@brandingbrand/fsapp';

declare module '@brandingbrand/fsapp' {
  let env: import('@brandingbrand/kernel-core').Config<
    import('@brandingbrand/kernel-app').App
  >;
}
```

In your env file, `.kernelrc/env/env.*.ts` you can now utilize the [**triple-dash directive**](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html) to utilize this type outside the `src/` directory. To follow along, check out this [**example**](https://github.com/brandingbrand/flagship/blob/feat/flagship-12/apps/react-native/.kernelrc/env/env.prod.ts).


`env.prod.ts`
```
/// <reference path="../../src/types/app.d.ts" />

import {ENV} from '@brandingbrand/kernel-app';

const prod: ENV = {
  ios: {
    name: 'kernel',
    bundleId: 'com.kernel',
    displayName: 'Kernel',
    .
    .
    .
  },
  android: {
    name: 'kernel',
    displayName: 'Kernel',
    packageName: 'com.kernel',
    .
    .
    .
  },
  app: {
    foo: 'bar',
    bar: 123,
  },
  kernelPluginAsset: {
    kernel: {
      assetPath: ['assets/fonts'],
    },
  },
};

export default prod;
```

If you are using `fsapp` to access the `env` object - the env is now typesafe at runtime.

### Plugins

Plugins are platform-specific scripts that generate or manipulate native code for a third-party dependency. Plugins are npm packages added as dev dependencies (only required when running the command `kernel init`). They may or may not export an interface that must be added to your environment, as shown in the previous section. Plugins are run by the `plugins` executor by auto-discovery. 

#### Linking

Plugins support remote or local distribution allowing for ultimate flexibility.

Link your plugins by adding them to the `package.json` `kernel.plugins` array in priority order. Plugins are run with async / await from 0th-index to Nth-index.

`package.json`
```
  "kernel": {
    "plugins": [
      "@brandingbrand/kernel-plugin-asset",
      "@brandingbrand/kernel-plugin-permissions",
      "@brandingbrand/kernel-plugin-native-navigation",
      "@brandingbrand/kernel-plugin-app-icon",
      .
      .
      .
    ]
  }
```

#### Generating

Generating a plugin assumes you have familiarity with creating JavaScript / TypeScript packages. A plugin is a TypeScript package and must abide by the interface of having `ios` and `android` named exports that accept the `Config` type; exported from `@brandingbrand/kernel-core`. As noted by the interface below, these are async functions - all plugins are run via async / await.

`index.d.ts`
```
declare const ios: (config: Config) => Promise<void>;
declare const android: (config: Config) => Promise<void>;
```

The config interface can also be an intersection type of the `Config` and the interface of the plugin i.e. `KernelPluginAppIcon`.

`index.d.ts`
```
declare const ios: (config: Config & KernelPluginAppIcon) => Promise<void>;
declare const android: (config: Config & KernelPluginAppIcon) => Promise<void>;
```

There are a number of ways to compile / bundle your TypeScript to JavaScript. In this monorepo [**microbundle**](https://www.npmjs.com/package/microbundle) is utilized to compile and bundle TypeScript into JavaScript.

A very simple plugin that can be used as inspiration to generate your own plugin is the local plugin [**example**](https://github.com/brandingbrand/flagship/tree/feat/flagship-12/apps/react-native/.kernelrc/plugins/plugin-local) - the only difference being that if you are distrbuting this package to npm you would not persist the `dist` directory. 

If you are making a true local plugin, you would persist the `dist` directory. It's strongly recommended that each plugin have it's own set of unit tests than can be run via [**jest**](https://jestjs.io/).
