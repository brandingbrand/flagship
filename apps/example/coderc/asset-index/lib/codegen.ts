import ts from 'typescript';

export interface AssetMetadataGeneratorOpts {
  color?: string;
  height: number;
  name: string;
  source: string | Record<string, string>;
  width: number;
}

function getPropertyKey(property: ts.PropertyAssignment) {
  if (ts.isIdentifier(property.name)) {
    return property.name.escapedText;
  }

  throw new Error('Unsupported property name type');
}

function sortPropertyAssignments(
  properties: ts.PropertyAssignment[],
): ts.PropertyAssignment[] {
  return properties.sort((a, b) =>
    getPropertyKey(a) < getPropertyKey(b) ? -1 : 1,
  );
}

function withAutogeneratedFileHeader(file: string): string {
  return `/* AUTOGENERATED FILE. DO NOT EDIT. RUN "yarn generate:asset-index" TO REGENERATE. */
${file}`;
}

function createNamedImportDeclaration(
  namedImports:
    | {isTypeOnly?: boolean; name: string; propertyName?: string}[]
    | undefined,
  modulePath: string,
  isTypeOnly: boolean = false,
): ts.ImportDeclaration {
  return ts.factory.createImportDeclaration(
    undefined,
    ts.factory.createImportClause(
      isTypeOnly,
      undefined,
      namedImports
        ? ts.factory.createNamedImports(
            namedImports.map(it =>
              ts.factory.createImportSpecifier(
                it.isTypeOnly ?? false,
                it.propertyName
                  ? ts.factory.createIdentifier(it.propertyName)
                  : undefined,
                ts.factory.createIdentifier(it.name),
              ),
            ),
          )
        : undefined,
    ),
    ts.factory.createStringLiteral(modulePath),
  );
}

function createSatisfiesTypeReferenceExpression(
  expression: ts.Expression,
  typeName: string,
): ts.SatisfiesExpression {
  return ts.factory.createSatisfiesExpression(
    expression,
    ts.factory.createTypeReferenceNode(typeName),
  );
}

function createAsTypeReferenceExpression(
  expression: ts.Expression,
  typeName: string,
): ts.AsExpression {
  return ts.factory.createAsExpression(
    expression,
    ts.factory.createTypeReferenceNode(typeName),
  );
}

function createAsConstExpression(expression: ts.Expression): ts.AsExpression {
  return createAsTypeReferenceExpression(expression, 'const');
}

function createRelativeRequireExpression(
  requirePath: string,
  asTypeName?: string,
): ts.CallExpression | ts.AsExpression {
  const requireExpression = ts.factory.createCallExpression(
    ts.factory.createIdentifier('require'),
    undefined,
    [ts.factory.createStringLiteral(`./${requirePath}`)],
  );

  return asTypeName
    ? createAsTypeReferenceExpression(requireExpression, asTypeName)
    : requireExpression;
}

function createAssetSource(
  requirePath: string | Record<string, string>,
  asTypeName?: string,
): ts.AsExpression | ts.CallExpression | ts.ObjectLiteralExpression {
  if (typeof requirePath === 'string') {
    return createRelativeRequireExpression(requirePath, asTypeName);
  }

  return ts.factory.createObjectLiteralExpression(
    sortPropertyAssignments(
      Object.entries(requirePath).map(([key, path]) =>
        ts.factory.createPropertyAssignment(
          key,
          createRelativeRequireExpression(path, asTypeName),
        ),
      ),
    ),
    true,
  );
}

function createAssetManifestPropertyAssignment(
  opts: AssetMetadataGeneratorOpts,
): ts.PropertyAssignment {
  const properties = [
    ts.factory.createPropertyAssignment(
      'source',
      createAssetSource(opts.source, 'ImageRequireSource'),
    ),
    ts.factory.createPropertyAssignment(
      'width',
      ts.factory.createNumericLiteral(opts.width),
    ),
    ts.factory.createPropertyAssignment(
      'height',
      ts.factory.createNumericLiteral(opts.height),
    ),
  ];

  if (opts.color) {
    properties.push(
      ts.factory.createPropertyAssignment(
        'color',
        ts.factory.createStringLiteral(opts.color),
      ),
    );
  }

  return ts.factory.createPropertyAssignment(
    opts.name,
    ts.factory.createObjectLiteralExpression(properties, true),
  );
}

export function createAssetRequireMapFile(
  assetData: AssetMetadataGeneratorOpts[],
): string {
  let file = ts.factory.createSourceFile(
    [
      createNamedImportDeclaration(
        [{name: 'ImageRequireSource'}],
        'react-native',
        true,
      ),
      ts.factory.createExportDefault(
        createAsConstExpression(
          ts.factory.createObjectLiteralExpression(
            sortPropertyAssignments(
              assetData.map(meta =>
                ts.factory.createPropertyAssignment(
                  meta.name,
                  createAssetSource(meta.source, 'ImageRequireSource'),
                ),
              ),
            ),
            true,
          ),
        ),
      ),
    ],
    ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
    ts.NodeFlags.None,
  );

  const printer = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed,
    removeComments: false,

    omitTrailingSemicolon: false,
  });

  return withAutogeneratedFileHeader(printer.printFile(file));
}

export function createAssetManifestFile(
  assetData: AssetMetadataGeneratorOpts[],
): string {
  const file = ts.factory.createSourceFile(
    [
      createNamedImportDeclaration(
        [{name: 'ImageRequireSource'}],
        'react-native',
        true,
      ),
      createNamedImportDeclaration(
        [{name: 'AssetManifest'}],
        '@/shared/lib',
        true,
      ),
      ts.factory.createExportDefault(
        createSatisfiesTypeReferenceExpression(
          ts.factory.createObjectLiteralExpression(
            sortPropertyAssignments(
              assetData.map(createAssetManifestPropertyAssignment),
            ),
            true,
          ),
          'AssetManifest',
        ),
      ),
    ],
    ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
    ts.NodeFlags.None,
  );

  const printer = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed,
    omitTrailingSemicolon: false,
  });

  return withAutogeneratedFileHeader(printer.printFile(file));
}
